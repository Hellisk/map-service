package edu.uq.dke.mapupdate.evaluation;

import edu.uq.dke.mapupdate.util.io.CSVRawMapReader;
import edu.uq.dke.mapupdate.util.object.datastructure.Pair;
import edu.uq.dke.mapupdate.util.object.datastructure.TrajectoryMatchingResult;
import edu.uq.dke.mapupdate.util.object.roadnetwork.RoadNetworkGraph;
import edu.uq.dke.mapupdate.util.object.roadnetwork.RoadWay;

import java.io.IOException;
import java.util.*;

import static edu.uq.dke.mapupdate.Main.ROOT_PATH;

/**
 * Created by uqpchao on 10/07/2017.
 */
public class TrajMatchingEvaluation {

    /**
     * Evaluate the precision and recall of the Beijing map-matching
     *
     * @param matchedResult     The matching results of map-matching algorithm
     * @param groundTruthResult The ground-truth matching results
     * @param currentMap        The map used in current map-matching
     * @param removedEdges      The removed edges, the combination of removed edges and currentMap will generate a complete road way dictionary
     */
    public void beijingPrecisionRecallCalc(List<TrajectoryMatchingResult> matchedResult, List<Pair<Integer, List<String>>>
            groundTruthResult, RoadNetworkGraph currentMap, List<RoadWay> removedEdges) {
        // insert all ground truth road match into gtResultList
        Map<Integer, HashSet<String>> gtResultList = new HashMap<>();
        for (Pair<Integer, List<String>> gtResult : groundTruthResult) {
            HashSet<String> gtRoadIDList = new HashSet<>(gtResult._2());
            gtResultList.put(gtResult._1(), gtRoadIDList);
        }

        // prepare the mapping of road id to road way length
        Map<String, Double> id2RoadLength = new HashMap<>();
        for (RoadWay w : currentMap.getWays())
            id2RoadLength.put(w.getID(), w.getRoadLength());
        for (RoadWay w : removedEdges) {
            if (!id2RoadLength.containsKey(w.getID()))
                id2RoadLength.put(w.getID(), w.getRoadLength());
        }
        // start the count
        double totalCorrectlyMatchedLength = 0;      // total length of perfectly matched road ways
        double totalMatchedLength = 0;    // total length of the road ways that are matched incorrectly
        double totalGroundTruthLength = 0;    // total length of the ground-truth road ways

        for (TrajectoryMatchingResult r : matchedResult) {
            Set<String> matchRoadIDSet = new LinkedHashSet<>(r.getBestMatchWayList());
            double currMatchedLength = 0;
            // summarize all matched road length
            for (String s : matchRoadIDSet) {
                currMatchedLength += id2RoadLength.get(s);
            }
            double correctlyMatchedLength = 0;
            // check the coverage of the roads found in our match
            HashSet<String> groundTruthIDList = gtResultList.get(Integer.parseInt(r.getTrajID()));
            double currGroundTruthLength = 0;
            for (String s : groundTruthIDList) {
                double currLength = id2RoadLength.get(s);
                currGroundTruthLength += currLength;
                if (matchRoadIDSet.contains(s)) {
                    correctlyMatchedLength += currLength;
                }
            }

            totalCorrectlyMatchedLength += correctlyMatchedLength;
            totalMatchedLength += currMatchedLength;
            totalGroundTruthLength += currGroundTruthLength;
        }

        double precision = totalCorrectlyMatchedLength / totalMatchedLength;
        double recall = totalCorrectlyMatchedLength / totalGroundTruthLength;

        System.out.println("Map-matching result evaluated, the precision is: " + precision * 100 + "%, the recall is:" + recall * 100 + "%");
    }

    /**
     * The precision/recall evaluation of the matching result, the precision is calculated by (total length of correct matches)/(total
     * length of all matches), the recall is similar.
     *
     * @param matchedResult             Matching results generated by algorithm
     * @param groundTruthResult         The ground-truth matching result
     * @param groundTruthTrajectoryInfo The features of each trajectory, like u-turn, break point, etc.
     */
    public void globalPrecisionRecallCalc(List<TrajectoryMatchingResult> matchedResult, List<Pair<Integer, List<String>>> groundTruthResult, List<Map<String, String>> groundTruthTrajectoryInfo) throws IOException {
        // insert all ground truth road match into globalCompareList
        Map<Integer, HashSet<String>> globalCompareList = new HashMap<>();
        for (Pair<Integer, List<String>> gtResult : groundTruthResult) {
            HashSet<String> gtRoadIDList = new LinkedHashSet<>(gtResult._2());
            globalCompareList.put(gtResult._1(), gtRoadIDList);
        }

        // start the comparison
        double totalCorrectlyMatchedLength = 0;      // total length of perfectly matched road ways
        double totalMatchedLength = 0;    // total length of the road ways that are matched incorrectly
        double totalGroundTruthLength = 0;    // total length of the ground-truth road ways
        CSVRawMapReader mapReader = new CSVRawMapReader(ROOT_PATH + "input/");

        for (TrajectoryMatchingResult r : matchedResult) {

            // read the corresponding map to extract actual length of each road
            RoadNetworkGraph currMap = mapReader.readRawMap(Integer.parseInt(r.getTrajID()));
            Map<String, Double> id2RoadLength = new HashMap<>();
            for (RoadWay w : currMap.getWays())
                id2RoadLength.put(w.getID(), w.getRoadLength());

            Set<String> matchRoadIDSet = new LinkedHashSet<>(r.getBestMatchWayList());
            double currMatchedLength = 0;
            // summarize all matched road length
            for (String s : matchRoadIDSet) {
                currMatchedLength += id2RoadLength.get(s);
            }
            double correctlyMatchedLength = 0;
            // check the coverage of the roads found in our match
            HashSet<String> groundTruthIDList = globalCompareList.get(Integer.parseInt(r.getTrajID()));
            double currGroundTruthLength = 0;
            for (String s : groundTruthIDList) {
                double currLength = id2RoadLength.get(s);
                currGroundTruthLength += currLength;
                if (matchRoadIDSet.contains(s)) {
                    correctlyMatchedLength += currLength;
                }
            }
            System.out.println("Trajectory " + r.getTrajID() + ": Precision=" + correctlyMatchedLength / currMatchedLength + ", " +
                    "recall=" + correctlyMatchedLength / currGroundTruthLength);
            totalMatchedLength += currMatchedLength;
            totalCorrectlyMatchedLength += correctlyMatchedLength;
            totalGroundTruthLength += currGroundTruthLength;
        }

        double precision = totalCorrectlyMatchedLength / totalMatchedLength;
        double recall = totalCorrectlyMatchedLength / totalGroundTruthLength;

        System.out.println("Map-matching result evaluated, the precision is: " + precision * 100 + "%, the recall is:" + recall * 100 + "%");
    }
}