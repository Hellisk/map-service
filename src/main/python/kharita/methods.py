from collections import defaultdict

import datetime
import geopy
import geopy.distance
import math
import numpy as np
import operator
from scipy.spatial import cKDTree


class GpsPoint:
    def __init__(self, vehicule_id=None, lon=None, lat=None, speed=None, timestamp=None, angle=None):
        self.vehicule_id = int(vehicule_id) if vehicule_id != None else 0
        self.speed = float(speed) if speed != None else 0.0
        self.timestamp = datetime.datetime.strptime(timestamp, '%Y-%m-%d %H:%M:%S+03') if timestamp != None else 0
        self.lon = float(lon)
        self.lat = float(lat)
        self.angle = float(angle)

    def get_coordinates(self):
        """
        return the lon,lat of a gps point
        :return: tuple (lon, lat)
        """
        return (self.lat, self.lon)

    def get_lonlat(self):
        return (self.lon, self.lat)

    def __str__(self):
        return "bt_id:%s, speed:%s, timestamp:%s, lon:%s, lat:%s, angle:%s" % \
               (self.vehicule_id, self.speed, self.timestamp, self.lon, self.lat, self.angle)

    def __repr__(self):
        return "bt_id:%s, speed:%s, timestamp:%s, lon:%s, lat:%s, angle:%s" % \
               (self.vehicule_id, self.speed, self.timestamp, self.lon, self.lat, self.angle)


class Cluster:
    def __init__(self, cid=None, nb_points=None, last_seen=None, lat=None, lon=None, angle=None):
        self.cid = cid
        self.lon = lon
        self.lat = lat
        self.angle = angle
        self.last_seen = last_seen
        self.nb_points = nb_points
        self.points = []

    def get_coordinates(self):
        return (self.lat, self.lon)

    def get_lonlat(self):
        return (self.lon, self.lat)

    def add(self, point):
        self.points.append(point)
        self.nb_points += 1
        self.last_seen = point.timestamp

    # self._recompute_center()

    def _recompute_center(self):
        self.lon = sum([p.lon for p in self.points]) / len(self.points)
        self.lat = sum([p.lat for p in self.points]) / len(self.points)
        self.angle = self._meanangle([p.angle for p in self.points])

    def _meanangle(self, anglelist):
        """
        Author: Rade Stanojevic.
        Computes the average value of a list of angles expressed in 0-360 interval.
        :param anglelist: list of angles
        :return: average
        """
        return (np.arctan2(sum([np.sin(alpha / 360 * 2 * np.pi) for alpha in anglelist]),
                           sum([np.cos(alpha / 360 * 2 * np.pi) for alpha in anglelist])) * 180 / np.pi)


def satisfy_path_condition_distance(s, t, g, clusters, alpha):
    """
    return False if there's a path of length max length, True otherwise
    :param s:
    :param t:
    :param k_reach:
    :return:
    """
    if s == -1 or t == -1 or s == t:
        return False

    edge_distance = geopy.distance.distance(geopy.Point(clusters[s].get_coordinates()), \
                                            geopy.Point(clusters[t].get_coordinates())).meters
    if not nx.has_path(g, s, t):
        return True
    path = nx.shortest_path(g, source=s, target=t)
    path_length_meters = 0
    for i in range(1, len(path)):
        path_length_meters += geopy.distance.distance(geopy.Point(clusters[path[i - 1]].get_coordinates()), \
                                                      geopy.Point(clusters[path[i]].get_coordinates())).meters
    if path_length_meters >= alpha * edge_distance:
        return True
    return False


def load_data(fname='data/gps_data/gps_points.csv'):
    """
    Given a file that contains gps points, this method creates different data structures
    :param fname: the name of the input file, as generated by QMIC
    :return: data_points (list of gps positions with their metadata), raw_points (coordinates only),
    points_tree is the KDTree structure to enable searching the points space
    """
    data_points = list()
    raw_points = list()

    with open(fname, 'r') as f:
        f.readline()
        for line in f:
            if len(line) < 10:
                continue
            vehicule_id, timestamp, lat, lon, speed, angle = line.split(',')
            pt = GpsPoint(vehicule_id=vehicule_id, timestamp=timestamp, lat=lat, lon=lon, speed=speed, angle=angle)
            data_points.append(pt)
            raw_points.append(pt.get_coordinates())
    points_tree = cKDTree(raw_points)
    return np.array(data_points), np.array(raw_points), points_tree


def create_trajectories(INPUT_FILE_NAME='data/gps_data/gps_points_07-11.csv', waiting_threshold=5):
    """
    return all trajectories.
    The heuristic is simple. Consider each users sorted traces not broken by more than 1 hour as trajectories.
    :param waiting_threshold: threshold for trajectory split expressed in seconds.
    :return: list of lists of trajectories
    """

    data_points, raw_points, points_tree = load_data(fname=INPUT_FILE_NAME)
    detections = defaultdict(list)
    for p in data_points:
        detections[p.vehicule_id].append(p)

    # compute trajectories: split detections by waiting_threshold
    print 'Computing trajectories'
    trajectories = []
    for btd, ldetections in detections.iteritems():
        points = sorted(ldetections, key=operator.attrgetter('timestamp'))
        source = 0
        prev_point = 0
        i = 1
        while i < len(points):
            delta = points[i].timestamp - points[prev_point].timestamp
            if delta.days * 24 * 3600 + delta.seconds > waiting_threshold:
                trajectories.append(points[source: i])
                source = i
            prev_point = i
            i += 1
        if source < len(points):
            trajectories.append(points[source: -1])
    return trajectories


def diffangles(a1, a2):
    """
    Difference between two angles in 0-360 degrees.
    :param a1: angle 1
    :param a2: angle 2
    :return: difference
    """
    return 180 - abs(abs(a1 - a2) - 180)


def partition_edge(edge, distance_interval):
    """
    given an edge, creates holes every x meters (distance_interval)
    :param edge: a given edge
    :param distance_interval: in meters
    :return: list of holes
    """

    # We always return the source node of the edge, hopefully the target will be added as the source of another edge.
    holes = []
    d = geopy.distance.VincentyDistance(meters=distance_interval)
    # make sure we are using lat,lon not lon,lat as a reference.
    startpoint = geopy.Point(edge[0].get_coordinates())
    endpoint = geopy.Point(edge[1].get_coordinates())
    initial_dist = geopy.distance.distance(startpoint, endpoint).meters
    if initial_dist < distance_interval:
        # return [], distance_interval - initial_dist
        return holes
    # compute the angle=bearing at which we need to be moving.
    bearing = calculate_bearing(startpoint[0], startpoint[1], endpoint[0], endpoint[1])
    last_point = startpoint
    diff_time = edge[1].last_seen - edge[0].last_seen
    delta_time = diff_time.days * 24 * 3600 + diff_time.seconds
    time_increment = delta_time / (int(initial_dist) / distance_interval)
    for i in range(int(initial_dist) / distance_interval):
        new_point = geopy.Point(d.destination(point=last_point, bearing=bearing))
        str_timestamp = datetime.datetime.strftime(edge[0].last_seen + datetime.timedelta(seconds=time_increment), "%Y-%m-%d %H:%M:%S+03")
        holes.append(GpsPoint(lat=new_point.latitude, lon=new_point.longitude, angle=bearing,
                              timestamp=str_timestamp))
        last_point = new_point
    # return holes, initial_dist - (initial_dist / distance_interval) * distance_interval
    return holes


def calculate_bearing(latitude_1, longitude_1, latitude_2, longitude_2):
    """
    Got it from this link: http://pastebin.com/JbhWKJ5m
   Calculation of direction between two geographical points
   """
    rlat1 = math.radians(latitude_1)
    rlat2 = math.radians(latitude_2)
    rlon1 = math.radians(longitude_1)
    rlon2 = math.radians(longitude_2)
    drlon = rlon2 - rlon1

    b = math.atan2(math.sin(drlon) * math.cos(rlat2), math.cos(rlat1) * math.sin(rlat2) -
                   math.sin(rlat1) * math.cos(rlat2) * math.cos(drlon))
    return (math.degrees(b) + 360) % 360


def vector_direction_re_north(s, d):
    """
    Make the source as the reference of the plan. Then compute atan2 of the resulting destination point
    :param s: source point
    :param d: destination point
    :return: angle!
    """

    # find the new coordinates of the destination point in a plan originated at source.
    new_d_lon = d.lon - s.lon
    new_d_lat = d.lat - s.lat
    angle = -math.degrees(math.atan2(new_d_lat, new_d_lon)) + 90

    # the following is required to move the degrees from -180, 180 to 0, 360
    if angle < 0:
        angle = angle + 360
    return angle
